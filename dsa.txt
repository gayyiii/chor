//Queue

#include<iostream>
using namespace std;

#define MAX 5   // ? Fixed

class Queue{
	int arr[MAX];
	int front, rear;
	
	public:
		Queue(){
			front = -1;
			rear = -1;
		}
		
		// Function to insert element in queue
		void enqueue(int x){
			if (rear == MAX - 1){
				cout << "Queue Overflow (Queue is full)\n";
				return;
			}
			if(front == -1)  // first element
				front = 0;
			
			arr[++rear] = x;
			cout << x << " inserted into queue\n";
		}
		
		void dequeue(){
			if(front == -1 || front > rear){
				cout << "Queue Underflow (Queue is empty)\n";
				return;
			}
			
			cout << arr[front] << " removed from queue\n";
			front++;
		}
		
		void display(){
			if(front == -1 || front > rear){
				cout << "Queue is empty\n";
				return;
			}
			cout << "Queue elements: ";
			for(int i = front; i <= rear; i++){
				cout << arr[i] << " ";
			}
			cout << endl;
		}
};

int main(){
	Queue q;
	int choice, value;
	do{
		cout << "\n----Queue Menu---\n";
		cout << "1. Enqueue (Insert)\n";
		cout << "2. Dequeue (Remove)\n";
		cout << "3. Display\n";
		cout << "4. Exit\n";
		cout << "Enter your choice: ";
		cin >> choice;
		
		switch(choice){
			case 1:
				cout << "Enter value to insert: ";
				cin >> value;
				q.enqueue(value);
				break;
			case 2:
				q.dequeue();
				break;
			case 3:
				q.display();
				break;
			case 4:
				cout << "Exiting...\n";
				break;
			default:
				cout << "Invalid choice\n";
		}
		
	} while(choice != 4);
	
	return 0;
}

//DEQUEUE

#include<iostream>
#define SIZE 5   // maximum size of deque

using namespace std;

int deque[SIZE];
int f = -1, r = -1;

// insert_front function will insert the value from the front
void insert_front(int x) {
    if ((f == 0 && r == SIZE - 1) || (f == r + 1)) {
        cout << "Overflow" << endl;
    } else if (f == -1 && r == -1) {  // first element
        f = r = 0;
        deque[f] = x;
    } else if (f == 0) {
        f = SIZE - 1;   // wrap around
        deque[f] = x;
    } else {
        f = f - 1;
        deque[f] = x;
    }
}

// insert_rear function will insert the value from the rear
void insert_rear(int x) {
    if ((f == 0 && r == SIZE - 1) || (f == r + 1)) {
        cout << "Overflow" << endl;
    } else if (f == -1 && r == -1) {  // first element
        f = r = 0;
        deque[r] = x;
    } else if (r == SIZE - 1) {
        r = 0;   // wrap around
        deque[r] = x;
    } else {
        r++;
        deque[r] = x;
    }
}

// display function prints all the values of deque
void display() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
        return;
    }

    int i = f;
    cout << "Elements in deque are: ";
    while (i != r) {
        cout << deque[i] << " ";
        i = (i + 1) % SIZE;   // circular increment
    }
    cout << deque[r] << endl;
}

// getfront function retrieves the first value of the deque
void getfront() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else {
        cout << "The value at the front is: " << deque[f] << endl;
    }
}

// getrear function retrieves the last value of the deque
void getrear() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else {
        cout << "The value at the rear is: " << deque[r] << endl;
    }
}

// delete_front() function deletes the element from the front
void delete_front() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else if (f == r) {  // only one element
        cout << "The deleted element is: " << deque[f] << endl;
        f = r = -1;
    } else if (f == SIZE - 1) {
        cout << "The deleted element is: " << deque[f] << endl;
        f = 0;  // wrap around
    } else {
        cout << "The deleted element is: " << deque[f] << endl;
        f = f + 1;
    }
}

// delete_rear() function deletes the element from the rear
void delete_rear() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else if (f == r) {  // only one element
        cout << "The deleted element is: " << deque[r] << endl;
        f = r = -1;
    } else if (r == 0) {
        cout << "The deleted element is: " << deque[r] << endl;
        r = SIZE - 1;   // wrap around
    } else {
        cout << "The deleted element is: " << deque[r] << endl;
        r = r - 1;
    }
}

// main function
int main() {
    insert_front(20);
    insert_front(10);
    insert_rear(30);
    insert_rear(50);
    insert_rear(80);

    display();     // Display the values of deque
    getfront();    // Retrieve the value at front-end
    getrear();     // Retrieve the value at rear-end

    delete_front();
    delete_rear();

    display();     // Display the values after deletion

    return 0;
}

//DEQUEUE

#include<iostream>
#define SIZE 5   // maximum size of deque

using namespace std;

int deque[SIZE];
int f = -1, r = -1;

// insert_front function will insert the value from the front
void insert_front(int x) {
    if ((f == 0 && r == SIZE - 1) || (f == r + 1)) {
        cout << "Overflow" << endl;
    } else if (f == -1 && r == -1) {  // first element
        f = r = 0;
        deque[f] = x;
    } else if (f == 0) {
        f = SIZE - 1;   // wrap around
        deque[f] = x;
    } else {
        f = f - 1;
        deque[f] = x;
    }
}

// insert_rear function will insert the value from the rear
void insert_rear(int x) {
    if ((f == 0 && r == SIZE - 1) || (f == r + 1)) {
        cout << "Overflow" << endl;
    } else if (f == -1 && r == -1) {  // first element
        f = r = 0;
        deque[r] = x;
    } else if (r == SIZE - 1) {
        r = 0;   // wrap around
        deque[r] = x;
    } else {
        r++;
        deque[r] = x;
    }
}

// display function prints all the values of deque
void display() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
        return;
    }

    int i = f;
    cout << "Elements in deque are: ";
    while (i != r) {
        cout << deque[i] << " ";
        i = (i + 1) % SIZE;   // circular increment
    }
    cout << deque[r] << endl;
}

// getfront function retrieves the first value of the deque
void getfront() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else {
        cout << "The value at the front is: " << deque[f] << endl;
    }
}

// getrear function retrieves the last value of the deque
void getrear() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else {
        cout << "The value at the rear is: " << deque[r] << endl;
    }
}

// delete_front() function deletes the element from the front
void delete_front() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else if (f == r) {  // only one element
        cout << "The deleted element is: " << deque[f] << endl;
        f = r = -1;
    } else if (f == SIZE - 1) {
        cout << "The deleted element is: " << deque[f] << endl;
        f = 0;  // wrap around
    } else {
        cout << "The deleted element is: " << deque[f] << endl;
        f = f + 1;
    }
}

// delete_rear() function deletes the element from the rear
void delete_rear() {
    if (f == -1 && r == -1) {
        cout << "Deque is empty" << endl;
    } else if (f == r) {  // only one element
        cout << "The deleted element is: " << deque[r] << endl;
        f = r = -1;
    } else if (r == 0) {
        cout << "The deleted element is: " << deque[r] << endl;
        r = SIZE - 1;   // wrap around
    } else {
        cout << "The deleted element is: " << deque[r] << endl;
        r = r - 1;
    }
}

// main function
int main() {
    insert_front(20);
    insert_front(10);
    insert_rear(30);
    insert_rear(50);
    insert_rear(80);

    display();     // Display the values of deque
    getfront();    // Retrieve the value at front-end
    getrear();     // Retrieve the value at rear-end

    delete_front();
    delete_rear();

    display();     // Display the values after deletion

    return 0;
}


//In order,Post order,pre order

#include <iostream>
using namespace std;

// Structure for a node in BST
struct Node {
    int data;
    Node *left, *right;

    // Constructor
    Node(int val) {
        data = val;
        left = right = NULL;
    }
};

// Function to insert a new value into the BST
Node* insert(Node* root, int val) {
    if (root == NULL)
        return new Node(val);

    if (val < root->data)
        root->left = insert(root->left, val);   // smaller ? left
    else if (val > root->data)
        root->right = insert(root->right, val); // greater ? right

    return root;
}

// Inorder Traversal (Left - Root - Right)
void inorder(Node* root) {
    if (root == NULL)
        return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

// Preorder Traversal (Root - Left - Right)
void preorder(Node* root) {
    if (root == NULL)
        return;
    cout << root->data << " ";
    preorder(root->left);
    preorder(root->right);
}

// Postorder Traversal (Left - Right - Root)
void postorder(Node* root) {
    if (root == NULL)
        return;
    postorder(root->left);
    postorder(root->right);
    cout << root->data << " ";
}

int main() {
    Node* root = NULL;   // Start with empty tree

    // Insert elements into BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    insert(root, 60);
    insert(root, 80);

    // Display traversals
    cout << "Inorder Traversal:   ";
    inorder(root);
    cout << endl;

    cout << "Preorder Traversal:  ";
    preorder(root);
    cout << endl;

    cout << "Postorder Traversal: ";
    postorder(root);
    cout << endl;

    return 0;
}
